@startuml

title __SERVER's Class Diagram__\n

  namespace server {
    class server.Challenge {
        - active : AtomicBoolean
        {static} - dict : List<String>
        - executor : ExecutorService
        - k1 : SelectionKey
        - k2 : SelectionKey
        - parole : List<String>
        - punteggio : int[]
        - traduzioni : List<String>
        - users : List<User>
        - wordN : int[]
        + Challenge()
        + endChallenge()
        + getOpponent()
        + getScore()
        + getWord()
        + isActive()
        + run()
        {static} + setDict()
        + setExecutor()
        + setKeys()
        + tryWord()
        - getParole()
        - parseOutput()
        - richiediTraduzione()
    }
  }
  

  namespace server {
    abstract class server.IChallenge {
        {abstract} ~ endChallenge()
        {abstract} ~ getOpponent()
        {abstract} ~ getScore()
        {abstract} ~ isActive()
    }
  }
  

  namespace server {
    interface server.IServerRMI {
        {abstract} + registraUtente()
    }
  }
  

  namespace server {
    interface server.IUser {
        {abstract} + addFriend()
        {abstract} + addPending()
        {abstract} + addScore()
        {abstract} + getFriends()
        {abstract} + getNickname()
        {abstract} + getPendings()
        {abstract} + getScore()
        {abstract} + hasFriend()
        {abstract} + isLogged()
        {abstract} + login()
        {abstract} + logout()
        {abstract} + removeFriend()
        {abstract} + removePending()
    }
  }
  

  namespace server {
    interface server.IUsers {
        {abstract} + addPending()
        {abstract} + aggiungiAmico()
        {abstract} + containsPending()
        {abstract} + exists()
        {abstract} + getFriends()
        {abstract} + getLeaderboard()
        {abstract} + getPendings()
        {abstract} + hasFriend()
        {abstract} + isLogged()
        {abstract} + login()
        {abstract} + logout()
        {abstract} + mostraPunteggio()
        {abstract} + registraUtente()
        {abstract} + removePending()
    }
  }
  

  namespace server {
    class server.MyAttachment {
        - UDPport : Integer
        - buffer : ByteBuffer
        - nick : String
        - response : String
        - token : String
        + getBuffer()
        + getNick()
        + getResponse()
        + getToken()
        + getUDPPort()
        + setNick()
        + setResponse()
        + setToken()
        + setUDPPort()
        ~ MyAttachment()
    }
  }
  

  namespace server {
    class server.Notifier {
        - k : SelectionKey
        - response : String
        + Notifier()
        + run()
    }
  }
  

  namespace server {
    class server.ReaderTCP {
        - executor : ExecutorService
        - k : SelectionKey
        - keys : ConcurrentHashMap<String, SelectionKey>
        - token : String
        + ReaderTCP()
        + accettaAmicizia()
        + accettaSfida()
        + aggiornaClassifiche()
        + amicizia()
        + get()
        + inoltraAmicizia()
        + inoltraRichiestaSfida()
        + inoltraSfida()
        + login()
        + logout()
        + manageCommand()
        + parola()
        + read()
        + richiediAmicizia()
        + richiediSfida()
        + rifiutaSfida()
        + run()
        + sfida()
    }
  }
  

  namespace server {
    class server.Server {
        - dict : List<String>
        {static} - n : int
        + Server()
        {static} + main()
        + save()
    }
  }
  

  namespace server {
    class server.ServerRMI {
        ~ port : int
        + ServerRMI()
        + registraUtente()
    }
  }
  

  namespace server {
    class server.ServerTCP {
        - executor : ExecutorService
        - keys : ConcurrentHashMap<String, SelectionKey>
        - selector : Selector
        - serverChannel : ServerSocketChannel
        - usingK : ConcurrentHashMap<SelectionKey, SelectionKey>
        + ServerTCP()
        + accept()
        + run()
    }
  }
  

  namespace server {
    abstract class server.TimerChallenge {
        ~ executor : ExecutorService
        + TimerChallenge()
    }
  }
  

  namespace server {
    class server.TimerChallengeEnd {
        - k1 : SelectionKey
        - k2 : SelectionKey
        - keys : ConcurrentHashMap<String, SelectionKey>
        + run()
        ~ TimerChallengeEnd()
        - aggiornaClassifiche()
    }
  }
  

  namespace server {
    class server.TimerChallengeRequest {
        - friend : String
        - k1 : SelectionKey
        - k2 : SelectionKey
        - nick : String
        + TimerChallengeRequest()
        + run()
    }
  }
  

  namespace server {
    class server.UDP {
        - address : InetAddress
        - udp : DatagramSocket
        + UDP()
        + write()
    }
  }
  

  namespace server {
    class server.User {
        - challengeRequest : ConcurrentHashMap<String, String>
        - friends : ConcurrentHashMap<String, String>
        - logged : boolean
        - nickname : String
        - password : String
        - pendingFriend : ConcurrentHashMap<String, String>
        - score : int
        - token : String
        + User()
        + User()
        + addChallengeRequest()
        + addFriend()
        + addPending()
        + addScore()
        + getChallenge()
        + getFriends()
        + getNickname()
        + getPassword()
        + getPendings()
        + getScore()
        + getToken()
        + hasChallengeRequest()
        + hasFriend()
        + isInChallenge()
        + isLogged()
        + login()
        + logout()
        + removeChallengeRequest()
        + removeFriend()
        + removePending()
        + setChallenge()
        + setNickname()
        + setPassword()
        + setScore()
        + toJSON()
    }
  }
  

  namespace server {
    class server.Users {
        - users : ConcurrentHashMap<String, User>
        + Users()
        + Users()
        + addPending()
        + addPendingChallenge()
        + aggiungiAmico()
        + containsPending()
        + exists()
        + getChallenge()
        + getFriends()
        + getIterator()
        + getLeaderboard()
        + getPendings()
        + getToken()
        + hasChallengeRequest()
        + hasFriend()
        + isInChallenge()
        + isLogged()
        + listaAmici()
        + listaRichieste()
        + login()
        + logout()
        + mostraClassifica()
        + mostraPunteggio()
        + registraUtente()
        + removePending()
        + removePendingChallenge()
        + sfida()
        + validateToken()
        - generateToken()
    }
  }
  

  namespace server {
    class server.WriterTCP {
        - k : SelectionKey
        - keys : ConcurrentHashMap<String, SelectionKey>
        + WriterTCP()
        + logout()
        + run()
        + send()
    }
  }
  

  server.Challenge .up.|> java.lang.Runnable
  server.Challenge -up-|> server.IChallenge
  server.Notifier .up.|> java.lang.Runnable
  server.ReaderTCP .up.|> java.lang.Runnable
  server.ReaderTCP o-- server.UDP : udp
  server.ReaderTCP o-- server.Users : users
  server.Server o-- server.Users : u
  server.Server o-- server.ServerRMI : serverrmi
  server.Server o-- server.ServerTCP : servertcp
  server.ServerRMI .up.|> server.IServerRMI
  server.ServerRMI -up-|> java.rmi.server.RemoteServer
  server.ServerRMI o-- server.Users : users
  server.ServerTCP .up.|> java.lang.Runnable
  server.ServerTCP o-- server.UDP : udp
  server.ServerTCP o-- server.Users : users
  server.TimerChallenge -up-|> java.util.TimerTask
  server.TimerChallengeEnd -up-|> server.TimerChallenge
  server.TimerChallengeEnd o-- server.Challenge : c
  server.TimerChallengeEnd o-- server.Users : users
  server.TimerChallengeRequest -up-|> server.TimerChallenge
  server.TimerChallengeRequest o-- server.Users : users
  server.User .up.|> server.IUser
  server.User o-- server.Challenge : challenge
  server.Users .up.|> server.IUsers
  server.WriterTCP .up.|> java.lang.Runnable
  server.WriterTCP o-- server.Users : users


right footer


PlantUML diagram generated by SketchIt! (https://bitbucket.org/pmesmeur/sketch.it)
For more information about this tool, please contact philippe.mesmeur@gmail.com
endfooter

@enduml
